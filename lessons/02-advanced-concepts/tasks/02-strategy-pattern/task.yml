# Task Configuration
title: "Strategy Pattern Implementation"
position: 2
category: "Design Patterns"
preparation: false
estimated_time_in_minutes: 15
always_unlocked: false

# Content
body_markdown: |
  ## Overview

  The Strategy pattern allows you to define a family of algorithms, encapsulate each one, and make them interchangeable. This task will have you implement different sorting strategies.

  ## Objectives

  1. Define a Strategy interface
  2. Implement multiple concrete strategies
  3. Create a context class that uses strategies
  4. Switch strategies at runtime

  ## Instructions

  ### Step 1: Define the Strategy Interface

  ```typescript
  export interface SortStrategy<T> {
    sort(items: T[]): T[];
  }
  ```

  ### Step 2: Implement Concrete Strategies

  ```typescript
  export class AscendingSort implements SortStrategy<number> {
    sort(items: number[]): number[] {
      return [...items].sort((a, b) => a - b);
    }
  }

  export class DescendingSort implements SortStrategy<number> {
    sort(items: number[]): number[] {
      return [...items].sort((a, b) => b - a);
    }
  }
  ```

  ### Step 3: Create the Context

  ```typescript
  export class Sorter<T> {
    private strategy: SortStrategy<T>;

    setStrategy(strategy: SortStrategy<T>): void {
      this.strategy = strategy;
    }

    sort(items: T[]): T[] {
      if (!this.strategy) {
        throw new Error('No strategy set');
      }
      return this.strategy.sort(items);
    }
  }
  ```

  ### Step 4: Test Runtime Switching

  ```typescript
  const sorter = new Sorter<number>();
  const numbers = [3, 1, 4, 1, 5, 9];

  sorter.setStrategy(new AscendingSort());
  console.log(sorter.sort(numbers)); // [1, 1, 3, 4, 5, 9]

  sorter.setStrategy(new DescendingSort());
  console.log(sorter.sort(numbers)); // [9, 5, 4, 3, 1, 1]
  ```

  ## Bonus: Custom Comparator Strategy

  Create a strategy that accepts a custom comparator function:

  ```typescript
  export class CustomSort<T> implements SortStrategy<T> {
    constructor(private comparator: (a: T, b: T) => number) {}

    sort(items: T[]): T[] {
      return [...items].sort(this.comparator);
    }
  }
  ```

  ## Success Criteria

  - [ ] Strategy interface defined
  - [ ] At least 2 concrete strategies implemented
  - [ ] Context class manages strategy switching
  - [ ] Strategies can be swapped at runtime
  - [ ] Original array is not mutated

# Git Integration
git_tag_completed: solution-strategy-pattern

